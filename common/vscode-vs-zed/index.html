<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.148.1">

  <title> &middot; Greg Herlein</title>

    

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://blog.herlein.com/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://blog.herlein.com/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://blog.herlein.com/css/blackburn.css">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">

  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Raleway&display=swap" rel="stylesheet" type="text/css">

  
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/androidstudio.min.css">
  <script async src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://blog.herlein.com/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://blog.herlein.com/">Herlein</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/about/"><i class='fa fa-user fa-fw'></i>About Me</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/projects/"><i class='fa fa-user fa-fw'></i>Projects</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/resume/"><i class='fa fa-user fa-fw'></i>Resume</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/staffing/"><i class='fa fa-user fa-fw'></i>Staffing</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2018-2025. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1></h1>
  <h2></h2>
</div>
<div class="content">
  <h1 id="agentic-development-in-zed-vs-visual-studio-code-mid2025-comparison">Agentic Development in Zed vs Visual Studio Code (Mid‑2025 Comparison)</h1>
<h2 id="llm-integration-native-support-vs-plugins">LLM Integration: Native Support vs Plugins</h2>
<ul>
<li>
<p><strong>Zed Editor:</strong> AI assistance is built-in as a first-class feature. Zed’s “assistant panel” and <em>Agentic Editing</em> are integrated into the core editor (no separate plugin required). Out of the box, Zed supports multiple large language models (LLMs) and providers – you can plug in OpenAI GPT-4, Anthropic Claude (e.g. Claude 2/3), Google’s PaLM/Gemini, and more, or even local models. Zed offers flexible options to <strong>“bring your own keys”</strong> for third-party APIs or run models locally via tools like Ollama/LM Studio. This means you’re not tied to a single vendor: for example, you can switch between Anthropic’s Claude and OpenAI’s GPT in a dropdown, or even use GitHub Copilot as a backend through Zed’s interface. All of this is handled natively by Zed’s Rust-based architecture and open-source AI agent panel, rather than through external extensions.</p>
</li>
<li>
<p><strong>Visual Studio Code:</strong> VS Code itself (open-source core) doesn’t include AI, but it has a rich <strong>plugin ecosystem</strong> to add AI-powered coding. The primary solution is <strong>GitHub Copilot</strong> (an official extension), which provides AI autocompletion and a chat assistant. By mid-2025, GitHub Copilot Chat offers deep editor integration – including an <em>Agent</em> chat mode for autonomous coding (more below). Copilot uses OpenAI’s models (GPT-4/GPT-3.5) via cloud; it’s not built into VS Code by default, but easily installed. In addition, VS Code’s marketplace has <strong>hundreds of AI extensions</strong> (over 400 as of 2023) from third parties. For example, the popular <strong>CodeGPT</strong> extension (1.9+ million installs) brings chat and code generation from multiple providers (OpenAI, Anthropic, Google, etc.). These extensions can connect to different model APIs, sometimes offering features like full-repository understanding via knowledge graphs. However, such integrations are plugin-based – i.e. you install and configure each extension. In summary, VS Code relies on its ecosystem (Copilot or others) for LLM support, whereas Zed comes with an AI-assistant framework out-of-the-box.</p>
</li>
</ul>
<h2 id="agent-based-coding-workflows-and-autonomous-agents">Agent-Based Coding Workflows and Autonomous Agents</h2>
<h3 id="zeds-agentic-editing">Zed’s <strong>Agentic Editing</strong></h3>
<p>Zed is designed for “agentic” AI-assisted programming – essentially, letting an AI agent act like a co-developer in your editor. Using natural language commands, you can instruct Zed’s agent to perform multi-step coding tasks across your project. Key aspects of Zed’s agentic workflow:</p>
<ul>
<li>
<p><strong>Codebase-Wide Reasoning:</strong> Zed’s agent can access your entire project. You can “chat” with the agent to ask questions about the code or request sweeping changes, without manually opening files. Notably, <strong>no manual pre-indexing</strong> is needed – the agent will <em>search the codebase on the fly</em> to gather relevant context. This automatic context discovery means you can jump right in with a request, and the AI will find the functions or files it needs (similar to how a developer would use grep/search).</p>
</li>
<li>
<p><strong>Autonomous Edits with Tools:</strong> Zed’s AI agent is capable of making changes across multiple files autonomously. Under the hood, it uses a suite of built-in <strong>tools</strong> to read, navigate, and modify code. For example, the agent can list or open files, search for text, read file contents, and even execute shell commands as needed. These tools let the AI do things akin to an Auto-GPT: it can run a build or tests, fetch external data (there’s a <code>web_search</code> and <code>fetch</code> tool for web queries), or create/edit files in the project (<code>create_file</code>, <code>edit_file</code>, etc.). Zed essentially provides a sandboxed API for the agent to interact with your workspace. This allows complex autonomous workflows – e.g. “Add a new API endpoint” might involve creating new files, modifying routing code, updating docs, and running tests, all handled by the agent with tool calls.</p>
</li>
<li>
<p><strong>Real-Time Collaboration and Feedback:</strong> Uniquely, Zed treats the AI agent as a real-time collaborator. The editor is <em>multiplayer by design</em>, so you can actually <strong>follow the agent’s cursor</strong> as it navigates your code in real-time. There’s a “follow mode” that scrolls to show whatever file/function the agent is currently examining. Zed also updates you at 120 FPS with the agent’s actions, so the interaction feels fluid. As the agent works, Zed’s UI shows an <strong>Agent Panel</strong> with a live log of its steps: which files it opened/edited, what tool actions it took, how many tokens used, etc.. This transparency helps you trust and verify the agent’s reasoning.</p>
</li>
<li>
<p><strong>Review and Control:</strong> Zed emphasizes that the human remains in charge. All AI-proposed changes across the codebase are presented in an editable <strong>unified diff view</strong> for review. You can go through the diff, make manual tweaks if needed (the diff is fully editable with Zed’s normal editing commands), and then accept the changes. This way, even large refactors are reviewed before they go live. If the agent gets something wrong or partially correct, you can refine the prompt or just edit the diff. You also get notified when the agent finishes or if it needs input, allowing it to run in the background for big tasks. Overall, Zed’s agentic workflow is meant to feel like delegating work to a smart junior developer: you give a natural-language task, the agent autonomously figures out the changes using tools, and you do the final code review.</p>
</li>
<li>
<p><strong>Extensibility of the Agent:</strong> Zed allows custom “agent tools” via an open standard called <strong>Model Context Protocol (MCP)</strong>. This means you can extend what the agent can do by plugging in external services as tools (for example, access a database, call an API, open a pull request, or control a browser). Some context-server extensions are already available, and developers can create their own MCP servers to integrate with Zed. In short, Zed’s agent is highly customizable – you’re not limited to the default toolset if your workflow needs something special.</p>
</li>
</ul>
<h3 id="vscodes-ai-agents-and-auto-gpt-style-tools">VS Code’s <strong>AI Agents and Auto-GPT Style Tools</strong></h3>
<p>Visual Studio Code has recently gained similar “agentic” capabilities primarily through GitHub Copilot’s Chat extension:</p>
<ul>
<li>
<p><strong>Copilot Chat – Agent Mode:</strong> By mid-2025, GitHub Copilot introduced an <strong>Agent mode</strong> in VS Code that lets the AI act autonomously on coding tasks. In the Copilot Chat panel, you can switch from the normal Q&amp;A mode to <em>Agent</em> mode. In Agent mode, you simply describe a high-level goal (e.g. “Migrate this app from Express to Fastify” or “Add a dark mode setting to the UI”) and the AI will <strong>plan and execute a series of steps</strong> to fulfill the request. This includes deciding which files to open or create and what edits to make – you do <em>not</em> have to point it to specific files yourself. The Copilot agent will autonomously determine the relevant context and code areas to change.</p>
</li>
<li>
<p><strong>Use of Tools:</strong> Under the hood, Copilot’s agent uses a tool-use paradigm very similar to Zed’s. It can invoke <strong>built-in editor/terminal tools</strong> to get its job done. For example, the agent can list files in the workspace, read file contents, edit a file, and run shell commands or VS Code tasks. This means if the agent needs to verify something or compile the code, it might automatically run your build task or execute tests. (In fact, if your project has build/test tasks defined, the agent will run them at appropriate times – e.g. after making changes, it might run tests and see if they pass.) Copilot’s agent monitors the results of these tool actions and can iterate: for instance, if tests fail or a compile error occurs, it will adjust the code in another pass to fix the issue. This loop is essentially an Auto-GPT-like self-correcting cycle, contained within VS Code.</p>
</li>
<li>
<p><strong>User Oversight and Confirmations:</strong> VS Code’s implementation puts an emphasis on safety and control. By default, when the AI is about to run a <em>destructive</em> or external action (like executing a terminal command or a non-builtin tool), you’ll get a confirmation prompt. You can allow the action once or always, to prevent the agent from, say, running a potentially dangerous script without you knowing. There’s a “Tools” menu in the chat interface where you can manage which tools the agent is permitted to use for a given session. (You can even manually trigger a specific tool by mentioning <code>#toolname</code> in your prompt, if you want to guide it.) Once the agent finishes its plan, VS Code shows the list of modified files (in bold) and overlays the diffs in the editor for review. You can navigate through each change and choose to accept or discard the edits one by one. This review step is similar in spirit to Zed’s diff review, ensuring the developer approves the final code.</p>
</li>
<li>
<p><strong>Extending VS Code’s Agent:</strong> Initially, Copilot’s agent comes with a set of built-in tools (file ops, search, terminal, etc.). VS Code is also embracing the idea of extensible agent tools through the same <strong>MCP (Model Context Protocol)</strong> concept. In fact, VS Code’s documentation explicitly mentions <strong>“MCP tools”</strong> and the ability to discover MCP servers configured in other tools. This means if you have external services or VS Code extensions that expose MCP-compatible commands, the Copilot agent can utilize them as well. Additionally, standard VS Code extensions can contribute new tools to the agent’s toolkit. For example, an extension could register a “database query” tool or a custom deployment command that the agent might invoke. This architecture is still evolving (as Agent mode was introduced around VS Code 1.99 in early 2025), but it shows that VS Code’s ecosystem will likely provide many add-ons to increase the agent’s capabilities. In summary, VS Code now supports agent-based workflows very akin to Auto-GPT: the Copilot agent can autonomously edit code and use tools/terminal, within the guardrails you set.</p>
</li>
<li>
<p><strong>Alternative Agent Workflows:</strong> Outside of Copilot, developers have also experimented with running autonomous coding agents in VS Code via extensions or manual setups. Some community extensions (for instance, <em>“VSCode GPT Automate”</em>) tried to integrate a ChatGPT-based agent to create files and run commands in the workspace, though these had limitations. Generally, prior to official support, one could run an Auto-GPT or LangChain script in a VS Code terminal – it could output code or write files – but the experience wasn’t seamless. Now that Microsoft’s own solution is available, VS Code provides a more polished UI for agentic development. It’s worth noting that, unlike Zed, VS Code’s built-in agent (Copilot) is tied to specific cloud models (OpenAI/Anthropic via GitHub) and requires at least a Copilot subscription or GitHub Enterprise license for full use. But thanks to VS Code’s openness, you do have the choice to use third-party AI agents or frameworks as extensions if you prefer a different model or approach.</p>
</li>
</ul>
<h2 id="developer-experience-and-performance">Developer Experience and Performance</h2>
<ul>
<li>
<p><strong>Performance and Speed:</strong> Zed is engineered for speed. Written in native code (Rust) with custom GPU rendering, it delivers a very snappy editing experience. Users frequently comment on its responsiveness – even compared to lightweight editors. In one benchmark, Zed could process an edit in ~58 ms, versus ~97 ms in VS Code (and 75 ms in Sublime Text). This performance advantage is noticeable when working with AI assistance: agent actions (like applying large diffs or navigating many files) feel smooth, without the lag that sometimes occurs in Electron-based editors. Zed’s UI updates in real-time as the agent works (120 FPS updates), and the editor remains responsive to user input even during background AI operations. By contrast, VS Code, running on Electron, has more overhead – large projects or extensive AI output can make it feel less snappy. Some developers describe Zed as “extremely fast and snappy, without the bloat of VS Code forks”. That said, on modern high-end machines VS Code still performs well, but Zed’s lightweight design gives it the edge in raw speed and low latency feedback.</p>
</li>
<li>
<p><strong>Resource Usage:</strong> With its native-code foundation, Zed tends to be efficient in memory and CPU usage for a given project size. VS Code, being essentially a Chromium browser instance, consumes more memory (especially once you add the Copilot extension or others). When an AI agent is running, VS Code might spawn processes for the language server, the Copilot backend, etc., which can tax system resources. Zed’s unified approach (editor and AI in one process) can be leaner. One practical example: editing very large files or performing project-wide refactors has been reported to feel smoother in Zed, whereas VS Code may stutter on huge files (as one user noted, Cursor – a VSCode fork – was sluggish on large files, but Zed handled them fine). Overall, if performance is a priority – for instance, if you want the AI agent to rapidly iterate over many files – Zed’s architecture is advantageous.</p>
</li>
<li>
<p><strong>Developer Interface &amp; Workflow:</strong> Both editors strive to make AI assistance intuitive, but they have different UI paradigms:</p>
<ul>
<li><em>Zed’s UI:</em> The AI conversation in Zed appears in a panel that is essentially a text editor buffer. Uniquely, Zed lets you <strong>edit the conversation text</strong> (including the AI’s responses) before re-sending, which advanced users leverage to fix small errors or remove irrelevant context. This editable chat history is a power-user feature that isn’t common in other tools. Zed’s agent panel also integrates with its multi-buffer interface – you can split the view to show code alongside the agent’s thread or diff review. Because Zed is “multiplayer”, the collaboration features (like seeing the agent’s cursor, or even inviting a teammate into the session) enhance the development workflow for pair-programming with AI. Moreover, Zed’s design philosophy is minimalistic: it lacks the myriad of sidebars and tabs that VS Code has, which some find refreshing. A comment on Reddit noted <em>“Zed shines in its simplicity. The fact it doesn&rsquo;t have tons of addons and extensions actually makes it better (less distraction, easier to focus)”</em>. On the flip side, this minimalism means some features developers expect are still being filled in (for example, a GUI for certain Git operations or an integrated debugger are relatively new or in beta on Zed).</li>
<li><em>VS Code’s UI:</em> Developers familiar with VS Code will find Copilot’s integration relatively seamless – it appears as a sidebar chat or inline suggestions. The agent mode adds some new UI elements (a mode toggle, a tools permission dialog, etc.), but generally it follows VS Code’s standard patterns. Reviewing AI changes in VS Code uses the existing diff view and Source Control panel, which many devs are already comfortable with. One advantage of VS Code’s maturity is that all the surrounding tooling (integrated terminal, version control UI, test runners, debuggers) are readily available as you use the AI. For instance, after the agent makes changes, you might run your debugger or view a Git diff within the same window. Zed is catching up on such integrated tooling (it has a terminal and basic debugger, but fewer extensions for custom workflows). In terms of <strong>learning curve</strong>, VS Code’s AI features may actually feel more complex at first (due to many settings, commands, and extension options to configure), whereas Zed offers a more guided experience (one integrated panel). Developers report that “everything just works” feeling in Zed’s design for AI and collaboration, as it avoids some of the configuration complexity.</li>
</ul>
</li>
<li>
<p><strong>Reliability and Polish:</strong> As of mid-2025, Zed’s agentic editing is a new entrant, and while powerful, some rough edges have been noted. Early adopters have occasionally found the AI behavior in Zed less predictable or lacking feedback compared to more mature systems. For example, one user noted frustration with Zed’s AI “not feeling seamless” and ended up switching back to Cursor (an AI-focused VSCode fork) for a while. Another pointed out that in Zed it wasn’t as easy to cherry-pick which suggested changes to accept or reject within a single file – you could edit the diff manually, but there was no quick checkbox per hunk like some other tools. The Zed team is actively improving these aspects, but it’s the nature of a young product that some workflows aren’t as refined yet. VS Code’s Copilot, by contrast, has seen iterations for over a year and benefits from GitHub/Microsoft’s UI expertise – the flow of asking, getting a plan, confirming tools, and applying edits has become reasonably smooth. Copilot’s suggestions (especially with GPT-4) are generally top-notch in quality for code tasks, whereas Zed’s default model (when using their free hosted Claude or the open-source “Zeta” model for completions) might sometimes lag in quality until you plug in a high-end model via API.</p>
</li>
<li>
<p><strong>Privacy and Offline Use:</strong> Zed puts a big emphasis on privacy and user control of AI. By default, your code and prompts are <strong>not sent to any server owned by Zed</strong> – if you use your own API key or local model, the data stays with those services or your machine. Zed does not log your conversations unless you opt-in to share them for improving the product. It’s also one of the few editors that supports completely offline AI usage (with local LLMs). You can configure a local  model (via Ollama or LM Studio) and the agent will use that with no internet required. For developers with sensitive code or air-gapped environments, this is a major plus for Zed. VS Code’s Copilot, on the other hand, always sends code and prompts to the cloud (OpenAI or Anthropic) when using the official plugin. Microsoft has policies to not retain or train on your code for Copilot (especially for enterprise users), but it’s still an external service operating on your code. There is no official offline mode for Copilot. If privacy is paramount, one would have to use a third-party VS Code extension that runs a local model (there are community extensions that hook up to local AI backends, but these may not support the full agent workflow). In summary, Zed gives more flexibility to stay local or control where the AI lives, whereas VS Code’s best AI features assume a cloud service.</p>
</li>
</ul>
<h2 id="customization-and-extensibility-for-agentic-workflows">Customization and Extensibility for Agentic Workflows</h2>
<ul>
<li>
<p><strong>Zed’s Customization:</strong> Being open-source and designed with AI in mind, Zed is highly customizable. You can fine-tune how the AI behaves via configuration files – for example, you can adjust the agent’s “temperature” setting or define custom system prompts (“rules”) to guide the model. Advanced users can even add <em>custom model profiles</em> in Zed’s settings to use experimental models or specific parameter presets. For extending functionality, Zed’s <strong>extension API</strong> and <strong>Context Server</strong> mechanism allow injection of new capabilities. If you have an external tool or script (say a special linter or a domain-specific code generator), you could expose it to Zed’s agent via the MCP interface, effectively teaching the AI a new “skill.” Zed’s extension store already includes some MCP servers (for example, one might connect to a web browser automation, or to AWS for cloud operations). Additionally, developers can create <strong>Slash Command extensions</strong> or other plugins in Zed to automate tasks or integrate with external APIs. While Zed’s ecosystem is smaller than VS Code’s, it is growing, and its focus on AI means many extensions revolve around enhancing AI workflows. The fact that Zed’s entire AI system is open source also means the community can build upon it; for instance, one could fork or modify the agent’s planning logic or contribute improvements.</p>
</li>
<li>
<p><strong>VS Code’s Extensibility:</strong> VS Code is famous for its extensibility, and that extends to AI tooling as well. Aside from Copilot, there are numerous <strong>AI SDKs and libraries</strong> that integrate with VS Code. For example, <strong>LangChain</strong> (a popular framework for building AI agents) doesn’t have a native VS Code plugin, but one could use VS Code’s Python or Node.js environment to run LangChain agents that interact with the file system. Some developers have created scripts to use LangChain or <strong>LangGraph</strong> (a framework for structured agent workflows) in concert with VS Code – typically running the agent in the terminal and letting it modify code, then coming back to the editor for review. It’s not as plug-and-play as Zed’s built-in agent, but it’s possible. More directly, VS Code’s extension API (in TypeScript/Node) allows anyone to write an extension that uses an LLM. The <strong>CodeGPT</strong> extension we mentioned, for instance, has its own notion of “AI Agents” and even a marketplace of shared agent prompts. This means a VS Code user can experiment with different AI assistants – say one extension specialized in code review bots, another for unit test generation, etc. – and mix and match them. The downside is that these extensions might not all share state or work together (you typically use them separately). However, with the advent of Copilot’s agent mode supporting <strong>tools from other extensions</strong>, we’re likely to see deeper integration: for example, a testing framework extension could register a “Run tests” tool that Copilot’s agent will use instead of its generic method, or a database extension could offer a “Run DB migration” tool for the agent. Microsoft’s embrace of the open MCP standard suggests a future where third-party “agent tool” plugins can be installed just like any VS Code extension, giving the AI new powers seamlessly in your workflow.</p>
</li>
<li>
<p><strong>Ecosystem and Community:</strong> VS Code’s huge community means if you need something specific for your agentic workflow, someone may have built it. Want an AI that follows your custom coding style guide? There might be an extension or you can script Copilot via the API (GitHub has started opening up Copilot for CLI and editor integration in other IDEs as well). There are also enterprise solutions built on VS Code – e.g. Amazon CodeWhisperer or Salesforce’s CodeGen (Einstein) integration – which come as VS Code plugins for specialized AI assistance. Zed’s community is more niche at the moment, but very enthusiastic. Many users contribute feedback on Zed’s GitHub and the team iterates quickly (Zed had rapid releases adding missing features throughout 2024–2025). If you have a very unique use case, you might end up building a custom VS Code extension (leveraging its APIs to read/write files and show results), whereas on Zed you might write a script using MCP or even modify the editor’s source. Zed’s <strong>“batteries-included”</strong> approach covers most common agentic use cases already, but VS Code’s <strong>“choose your own plugins”</strong> approach offers flexibility beyond that – albeit at the cost of integrating those pieces yourself.</p>
</li>
</ul>
<h2 id="strengths-and-weaknesses-summary">Strengths and Weaknesses Summary</h2>
<p><strong>Zed – Strengths:</strong> 🟢</p>
<ul>
<li><strong>Performance:</strong> Extremely fast and lightweight, providing near-instant feedback even when the AI agent is refactoring large codebases. It feels “lean and snappy” compared to Electron-based editors.</li>
<li><strong>Integrated AI Agent:</strong> Agentic editing is a native capability. No setup fuss – you get a powerful Auto-GPT-like coding partner out-of-the-box, with a thoughtful UI (chat in editor, real-time agent cursor) and seamless diff review for changes.</li>
<li><strong>Multi-Model Flexibility:</strong> Use your model of choice – OpenAI, Anthropic, Google, local open-source models, etc.. You can avoid proprietary lock-in or even work offline with local models. This also means cost control (use your own API keys or Zed’s usage-based model plans).</li>
<li><strong>Privacy &amp; Open-Source:</strong> Your code stays private (no telemetry of code by default). Zed is fully open-source (GPL) including its AI features, giving transparency. You can self-host models or even fork the editor.</li>
<li><strong>Collaboration Features:</strong> Real-time collaborative editing is built in. You and teammates (and the AI agent) can all edit together, which is great for pair programming or code review scenarios. Zed’s multiplayer editing and voice chat are unique among code editors at this performance level.</li>
<li><strong>Innovative UI:</strong> Features like editable chat transcripts (letting you correct the AI’s message and resend) and a unified diff that you can live-edit to tweak AI changes, make the AI workflow efficient for power users.</li>
<li><strong>Extensible via MCP:</strong> If the agent needs extra powers, Zed supports community-built extensions (e.g. connect the agent to a web browser or custom CLI) through an open protocol. It’s ready for creative integration into autonomous workflows.</li>
</ul>
<p><strong>Zed – Weaknesses:</strong> 🔴</p>
<ul>
<li><strong>Ecosystem Maturity:</strong> Zed’s ecosystem is young. It doesn’t (yet) have the thousands of extensions that VS Code does. Common tools (for example, certain linters, test explorers, or AWS deploy plugins) might not be available for Zed yet. If your workflow relies on a specific VS Code extension, Zed likely won’t have an equivalent immediately.</li>
<li><strong>Feature Gaps:</strong> As a newer editor, some features are still catching up – e.g. GUI git integration is basic compared to VS Code’s source control pane, and the built-in debugger is in beta. While Zed covers  syntax highlighting/LSP for many languages, niche language support might be less complete than VS Code’s vast extension library.</li>
<li><strong>AI Polish and Choices:</strong> Zed’s own AI model for inline completions (“Edit Prediction”) and other assistant features may not be as advanced as OpenAI’s latest. In fact, some advanced autocomplete capability in Zed has been moved behind a paid plan, which drew criticism. By contrast, VS Code users can still use basic IntelliSense and have a free tier of Copilot (limited). Also, a few users report that Zed’s agent can occasionally be inconsistent or harder to control in granular ways (e.g. partial acceptance of changes) compared to more mature tools. It’s improving rapidly, but it’s not <em>fully</em> battle-tested at the level of VS Code’s AI in all scenarios.</li>
<li><strong>Learning Curve for New Editor:</strong> Adopting Zed means switching editors, which comes with friction if you’re deeply used to VS Code. Keybindings, workflows, or integrated terminals behave a bit differently. For those who heavily customized VS Code, Zed might feel spartan – by design it foregoes some UI elements. This “less is more” approach might be a downside if you prefer a highly customized IDE environment.</li>
</ul>
<p><strong>VS Code – Strengths:</strong> 🟢</p>
<ul>
<li><strong>Extensive Ecosystem:</strong> VS Code’s biggest advantage is its rich extension library and community. Virtually every developer tool or cloud service has a VS Code extension. For AI specifically, you have multiple choices (Copilot, CodeGPT, TabNine, Codeium, etc.) and can augment them with tools like test runners, Docker integration, database GUIs – all in one editor. This means an <strong>integrated workflow</strong>: the AI agent can coexist with all your other tools in VS Code, making it easier to go from an AI suggestion to debugging to source control without switching context.</li>
<li><strong>Copilot’s AI Quality:</strong> GitHub Copilot (especially with GPT-4 in Copilot X) is a state-of-the-art code assistant. Its training on a huge code corpus and integration with the editor’s context often produces very relevant suggestions. The new agent mode benefits from OpenAI’s cutting-edge reasoning abilities. In practice, Copilot’s code generation and refactoring quality are proven by widespread use, whereas newer entrants are still building trust.</li>
<li><strong>Mature Editor Features:</strong> Outside of AI, VS Code is a full-featured IDE-like editor with stable support for debugging, profiling, intuitive Git UI, multiple project management, etc. When the AI agent suggests code that doesn’t work, you can easily step through it with the debugger or write tests and use VS Code’s testing panel. This maturity in surrounding features can accelerate verifying and refining AI-written code. Zed is improving here, but VS Code has the lead in “whole development lifecycle” tooling.</li>
<li><strong>Customization &amp; Control:</strong> Virtually every aspect of VS Code can be customized with settings or extensions – if you want the AI to behave differently, you might find an extension or setting to tweak it. For instance, you can adjust Copilot’s promiscuity in suggesting via settings, or use alternative AI extensions in tandem. Power users can even write small VS Code Extension Scripts to automate repetitive tasks. This flexibility means you can tailor the AI-assisted workflow heavily to your needs. Zed’s approach is more fixed (simpler, but less configurable in UI), whereas VS Code lets tinkerers craft their “perfect” setup.</li>
<li><strong>Community and Support:</strong> With millions of users, VS Code has extensive documentation, forums, and Q&amp;A for any issue. If the AI integration misbehaves, chances are someone has encountered it and there’s a GitHub issue or discussion about it. Microsoft’s active development on VS Code and Copilot also means frequent updates and quick bugfixes. In contrast, while the Zed team is very responsive, the user base is smaller – troubleshooting or finding workarounds might require more direct engagement with the Zed community.</li>
</ul>
<p><strong>VS Code – Weaknesses:</strong> 🔴</p>
<ul>
<li><strong>Performance Overhead:</strong> VS Code, running on Electron, is heavier on system resources. When using the AI agent, you might experience some sluggishness, especially on large projects or with many open files. The UI might freeze briefly if the agent is applying very large diffs or if multiple extensions are contending. It’s not a constant problem on good hardware, but side-by-side, Zed’s lightweight nature often feels more “instant” and distraction-free.</li>
<li><strong>Dependency on Cloud/Subscription:</strong> The best AI experience in VS Code (Copilot Chat with GPT-4) is a paid service with a monthly subscription or enterprise license. There is a free trial and a limited free plan, but heavy use requires payment. Also, without internet or outside of GitHub’s supported regions, Copilot won’t function. By contrast, Zed allows offline and bring-your-own model scenarios. So in environments where cloud access is restricted or budgets are tight, VS Code’s agentic capabilities might be less accessible. (Third-party free extensions exist but may not match Copilot’s capabilities or may rely on your OpenAI API key, which still incurs cost.)</li>
<li><strong>Privacy Concerns:</strong> Using VS Code with Copilot means your code prompts are sent to OpenAI/Microsoft servers. While they have privacy safeguards (and an enterprise option to ensure no training on your data), some companies or individuals remain uncomfortable with code leaving the local environment. Achieving a fully local AI solution in VS Code is possible but not straightforward – you’d need to use alternative extensions and host an LLM yourself. In Zed, it’s built-in and straightforward to keep everything local if desired.</li>
<li><strong>Complexity and Configuration:</strong> VS Code’s flexibility comes at the cost of complexity. New users might find it non-trivial to configure the AI the way they want – there are myriad settings (for example, enabling agent mode requires toggling a setting and ensuring you have the right VS Code version and Copilot extension version). Juggling multiple AI extensions can also lead to confusion or conflicts. Zed, with a singular integrated approach, can be simpler to use for AI assistance once you switch to it. In VS Code, if you don’t want to use Copilot, you must evaluate third-party tools – quality varies, and some features (like the official agent mode) might not be available outside Copilot. Essentially, there’s more <em>DIY</em> in VS Code’s approach to agentic dev if you stray from the default path.</li>
<li><strong>Not Built Ground-up for AI:</strong> Finally, VS Code, while now adapted for AI, wasn’t originally built with an AI collaborator in mind. Some workflows (like the way the editor handles very large inserts, or how it displays iterative AI changes) can feel a bit bolted-on. Zed’s philosophy of <em>“AI-native”</em> design (as their tagline suggests “built for collaboration with humans and AI”) means some interactions are more fluid (like seeing the agent’s live actions). VS Code is catching up fast, but there are moments (especially in early 2025) where the integration isn’t perfect – e.g. occasional glitches with the agent’s state or needing to reset tool permissions. These are minor and being improved, but reflect that VS Code is retrofitting AI features into an existing platform.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Both Zed and VS Code (with Copilot) have robust support for AI-assisted, agentic development as of mid-2025, but they cater to slightly different priorities:</p>
<ul>
<li>
<p><strong>Zed</strong> offers a sleek, high-performance environment where AI is deeply woven into the editing experience. It shines for developers who want an open, hackable editor with AI capabilities that can be customized (or even self-hosted) to their needs. If you value speed, privacy, and an all-in-one approach to an AI coding partner, Zed is a compelling choice – albeit one that might require adapting to a new editor and tolerating a few early-stage quirks.</p>
</li>
<li>
<p><strong>VS Code</strong>, on the other hand, provides a rich, time-tested development environment now augmented by powerful AI through Copilot. It’s ideal if you want a more mature ecosystem and don’t mind the cloud integration or subscription for top-tier AI. The agentic workflow in VS Code can dramatically boost productivity on complex tasks, and it benefits from VS Code’s extensive tooling around it. However, it’s a heavier solution and somewhat dependent on proprietary services.</p>
</li>
</ul>
<p>In practice, a developer aiming to use “Auto-GPT-style” autonomous coding can achieve it in <strong>both</strong> editors: Zed gives it to you out-of-the-box in a lightweight form, while VS Code lets you opt-in via Copilot or extensions to get similar capabilities. The best choice may come down to your personal workflow preferences: a streamlined new experience with Zed, or the feature-rich familiar world of VS Code.</p>
<p>Both are evolving rapidly, so we can expect even better integration of autonomous AI workflows in the near future. In mid-2025, it’s truly an exciting time – whether in Zed or VS Code – to experiment with AI agents that <em>“collaborate at 120fps”</em> alongside us in coding, turning natural-language plans into actual code. The tools are here; it’s a matter of which environment makes you more productive and comfortable as you build the future with AI assistance.</p>
<p><strong>Sources:</strong></p>
<ul>
<li><a href="https://zed.dev/docs">Zed official website and docs</a> – <a href="https://zed.dev/docs/ai">AI Features and Agentic Editing</a>, <a href="https://zed.dev/docs/configuration">Configuration options</a>, <a href="https://zed.dev/blog/fastest-ai-editor">&ldquo;Zed: The Fastest AI Code Editor&rdquo;</a> (Zed Blog, May 2025).</li>
<li><a href="https://code.visualstudio.com/docs">VS Code documentation</a> – <a href="https://code.visualstudio.com/docs/copilot/overview">Copilot Chat Agent Mode</a> (code.visualstudio.com, 2025).</li>
<li><a href="https://reddit.com/r/programming">Reddit discussions</a> and user feedback – <a href="https://reddit.com/r/programming/zed_vs_vscode">comparisons of Zed vs other editors</a>.</li>
<li>Media articles – <a href="https://analyticsindiamag.com">Analytics India Magazine on Zed vs VSCode forks</a>, <a href="https://medium.com/@robertbaer/zed-editor-review">Medium post on Zed</a> (Robert Baer), and <a href="https://vinh.dev/blog/zed-review">community blogs</a> (Vinh.dev).</li>
</ul>

</div>

</div>
</div>
<script src="https://blog.herlein.com/js/ui.js"></script>
<script src="https://blog.herlein.com/js/menus.js"></script>










</body>
</html>

