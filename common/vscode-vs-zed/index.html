<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.152.2">

  <title> &middot; Greg Herlein</title>

    

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://blog.herlein.com/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://blog.herlein.com/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://blog.herlein.com/css/blackburn.css">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">

  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Raleway&display=swap" rel="stylesheet" type="text/css">

  
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/androidstudio.min.css">
  <script async src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://blog.herlein.com/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://blog.herlein.com/">Herlein</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/about/"><i class='fa fa-user fa-fw'></i>About Me</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/projects/"><i class='fa fa-user fa-fw'></i>Projects</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/resume/"><i class='fa fa-user fa-fw'></i>Resume</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://blog.herlein.com/staffing/"><i class='fa fa-user fa-fw'></i>Staffing</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2018-2026. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1></h1>
  <h2></h2>
</div>
<div class="content">
  <h1 id="agentic-development-in-zed-vs-visual-studio-code-mid2025-comparison">Agentic Development in Zed vs Visual Studio Code (Midâ€‘2025 Comparison)</h1>
<h2 id="llm-integration-native-support-vs-plugins">LLM Integration: Native Support vs Plugins</h2>
<ul>
<li>
<p><strong>Zed Editor:</strong> AI assistance is built-in as a first-class feature. Zedâ€™s â€œassistant panelâ€ and <em>Agentic Editing</em> are integrated into the core editor (no separate plugin required). Out of the box, Zed supports multiple large language models (LLMs) and providers â€“ you can plug in OpenAI GPT-4, Anthropic Claude (e.g. Claude 2/3), Googleâ€™s PaLM/Gemini, and more, or even local models. Zed offers flexible options to <strong>â€œbring your own keysâ€</strong> for third-party APIs or run models locally via tools like Ollama/LM Studio. This means youâ€™re not tied to a single vendor: for example, you can switch between Anthropicâ€™s Claude and OpenAIâ€™s GPT in a dropdown, or even use GitHub Copilot as a backend through Zedâ€™s interface. All of this is handled natively by Zedâ€™s Rust-based architecture and open-source AI agent panel, rather than through external extensions.</p>
</li>
<li>
<p><strong>Visual Studio Code:</strong> VSÂ Code itself (open-source core) doesnâ€™t include AI, but it has a rich <strong>plugin ecosystem</strong> to add AI-powered coding. The primary solution is <strong>GitHub Copilot</strong> (an official extension), which provides AI autocompletion and a chat assistant. By mid-2025, GitHub Copilot Chat offers deep editor integration â€“ including an <em>Agent</em> chat mode for autonomous coding (more below). Copilot uses OpenAIâ€™s models (GPT-4/GPT-3.5) via cloud; itâ€™s not built into VSÂ Code by default, but easily installed. In addition, VSÂ Codeâ€™s marketplace has <strong>hundreds of AI extensions</strong> (over 400 as of 2023) from third parties. For example, the popular <strong>CodeGPT</strong> extension (1.9+ million installs) brings chat and code generation from multiple providers (OpenAI, Anthropic, Google, etc.). These extensions can connect to different model APIs, sometimes offering features like full-repository understanding via knowledge graphs. However, such integrations are plugin-based â€“ i.e. you install and configure each extension. In summary, VSÂ Code relies on its ecosystem (Copilot or others) for LLM support, whereas Zed comes with an AI-assistant framework out-of-the-box.</p>
</li>
</ul>
<h2 id="agent-based-coding-workflows-and-autonomous-agents">Agent-Based Coding Workflows and Autonomous Agents</h2>
<h3 id="zeds-agentic-editing">Zedâ€™s <strong>Agentic Editing</strong></h3>
<p>Zed is designed for â€œagenticâ€ AI-assisted programming â€“ essentially, letting an AI agent act like a co-developer in your editor. Using natural language commands, you can instruct Zedâ€™s agent to perform multi-step coding tasks across your project. Key aspects of Zedâ€™s agentic workflow:</p>
<ul>
<li>
<p><strong>Codebase-Wide Reasoning:</strong> Zedâ€™s agent can access your entire project. You can â€œchatâ€ with the agent to ask questions about the code or request sweeping changes, without manually opening files. Notably, <strong>no manual pre-indexing</strong> is needed â€“ the agent will <em>search the codebase on the fly</em> to gather relevant context. This automatic context discovery means you can jump right in with a request, and the AI will find the functions or files it needs (similar to how a developer would use grep/search).</p>
</li>
<li>
<p><strong>Autonomous Edits with Tools:</strong> Zedâ€™s AI agent is capable of making changes across multiple files autonomously. Under the hood, it uses a suite of built-in <strong>tools</strong> to read, navigate, and modify code. For example, the agent can list or open files, search for text, read file contents, and even execute shell commands as needed. These tools let the AI do things akin to an Auto-GPT: it can run a build or tests, fetch external data (thereâ€™s a <code>web_search</code> and <code>fetch</code> tool for web queries), or create/edit files in the project (<code>create_file</code>, <code>edit_file</code>, etc.). Zed essentially provides a sandboxed API for the agent to interact with your workspace. This allows complex autonomous workflows â€“ e.g. â€œAdd a new API endpointâ€ might involve creating new files, modifying routing code, updating docs, and running tests, all handled by the agent with tool calls.</p>
</li>
<li>
<p><strong>Real-Time Collaboration and Feedback:</strong> Uniquely, Zed treats the AI agent as a real-time collaborator. The editor is <em>multiplayer by design</em>, so you can actually <strong>follow the agentâ€™s cursor</strong> as it navigates your code in real-time. Thereâ€™s a â€œfollow modeâ€ that scrolls to show whatever file/function the agent is currently examining. Zed also updates you at 120Â FPS with the agentâ€™s actions, so the interaction feels fluid. As the agent works, Zedâ€™s UI shows an <strong>Agent Panel</strong> with a live log of its steps: which files it opened/edited, what tool actions it took, how many tokens used, etc.. This transparency helps you trust and verify the agentâ€™s reasoning.</p>
</li>
<li>
<p><strong>Review and Control:</strong> Zed emphasizes that the human remains in charge. All AI-proposed changes across the codebase are presented in an editable <strong>unified diff view</strong> for review. You can go through the diff, make manual tweaks if needed (the diff is fully editable with Zedâ€™s normal editing commands), and then accept the changes. This way, even large refactors are reviewed before they go live. If the agent gets something wrong or partially correct, you can refine the prompt or just edit the diff. You also get notified when the agent finishes or if it needs input, allowing it to run in the background for big tasks. Overall, Zedâ€™s agentic workflow is meant to feel like delegating work to a smart junior developer: you give a natural-language task, the agent autonomously figures out the changes using tools, and you do the final code review.</p>
</li>
<li>
<p><strong>Extensibility of the Agent:</strong> Zed allows custom â€œagent toolsâ€ via an open standard called <strong>Model Context Protocol (MCP)</strong>. This means you can extend what the agent can do by plugging in external services as tools (for example, access a database, call an API, open a pull request, or control a browser). Some context-server extensions are already available, and developers can create their own MCP servers to integrate with Zed. In short, Zedâ€™s agent is highly customizable â€“ youâ€™re not limited to the default toolset if your workflow needs something special.</p>
</li>
</ul>
<h3 id="vscodes-ai-agents-and-auto-gpt-style-tools">VSÂ Codeâ€™s <strong>AI Agents and Auto-GPT Style Tools</strong></h3>
<p>Visual Studio Code has recently gained similar â€œagenticâ€ capabilities primarily through GitHub Copilotâ€™s Chat extension:</p>
<ul>
<li>
<p><strong>Copilot Chat â€“ Agent Mode:</strong> By mid-2025, GitHub Copilot introduced an <strong>Agent mode</strong> in VSÂ Code that lets the AI act autonomously on coding tasks. In the Copilot Chat panel, you can switch from the normal Q&amp;A mode to <em>Agent</em> mode. In Agent mode, you simply describe a high-level goal (e.g. â€œMigrate this app from Express to Fastifyâ€ or â€œAdd a dark mode setting to the UIâ€) and the AI will <strong>plan and execute a series of steps</strong> to fulfill the request. This includes deciding which files to open or create and what edits to make â€“ you do <em>not</em> have to point it to specific files yourself. The Copilot agent will autonomously determine the relevant context and code areas to change.</p>
</li>
<li>
<p><strong>Use of Tools:</strong> Under the hood, Copilotâ€™s agent uses a tool-use paradigm very similar to Zedâ€™s. It can invoke <strong>built-in editor/terminal tools</strong> to get its job done. For example, the agent can list files in the workspace, read file contents, edit a file, and run shell commands or VSÂ Code tasks. This means if the agent needs to verify something or compile the code, it might automatically run your build task or execute tests. (In fact, if your project has build/test tasks defined, the agent will run them at appropriate times â€“ e.g. after making changes, it might run tests and see if they pass.) Copilotâ€™s agent monitors the results of these tool actions and can iterate: for instance, if tests fail or a compile error occurs, it will adjust the code in another pass to fix the issue. This loop is essentially an Auto-GPT-like self-correcting cycle, contained within VSÂ Code.</p>
</li>
<li>
<p><strong>User Oversight and Confirmations:</strong> VSÂ Codeâ€™s implementation puts an emphasis on safety and control. By default, when the AI is about to run a <em>destructive</em> or external action (like executing a terminal command or a non-builtin tool), youâ€™ll get a confirmation prompt. You can allow the action once or always, to prevent the agent from, say, running a potentially dangerous script without you knowing. Thereâ€™s a â€œToolsâ€ menu in the chat interface where you can manage which tools the agent is permitted to use for a given session. (You can even manually trigger a specific tool by mentioning <code>#toolname</code> in your prompt, if you want to guide it.) Once the agent finishes its plan, VSÂ Code shows the list of modified files (in bold) and overlays the diffs in the editor for review. You can navigate through each change and choose to accept or discard the edits one by one. This review step is similar in spirit to Zedâ€™s diff review, ensuring the developer approves the final code.</p>
</li>
<li>
<p><strong>Extending VSÂ Codeâ€™s Agent:</strong> Initially, Copilotâ€™s agent comes with a set of built-in tools (file ops, search, terminal, etc.). VSÂ Code is also embracing the idea of extensible agent tools through the same <strong>MCP (Model Context Protocol)</strong> concept. In fact, VSÂ Codeâ€™s documentation explicitly mentions <strong>â€œMCP toolsâ€</strong> and the ability to discover MCP servers configured in other tools. This means if you have external services or VSÂ Code extensions that expose MCP-compatible commands, the Copilot agent can utilize them as well. Additionally, standard VSÂ Code extensions can contribute new tools to the agentâ€™s toolkit. For example, an extension could register a â€œdatabase queryâ€ tool or a custom deployment command that the agent might invoke. This architecture is still evolving (as Agent mode was introduced around VSÂ Code 1.99 in early 2025), but it shows that VSÂ Codeâ€™s ecosystem will likely provide many add-ons to increase the agentâ€™s capabilities. In summary, VSÂ Code now supports agent-based workflows very akin to Auto-GPT: the Copilot agent can autonomously edit code and use tools/terminal, within the guardrails you set.</p>
</li>
<li>
<p><strong>Alternative Agent Workflows:</strong> Outside of Copilot, developers have also experimented with running autonomous coding agents in VSÂ Code via extensions or manual setups. Some community extensions (for instance, <em>â€œVSCode GPT Automateâ€</em>) tried to integrate a ChatGPT-based agent to create files and run commands in the workspace, though these had limitations. Generally, prior to official support, one could run an Auto-GPT or LangChain script in a VSÂ Code terminal â€“ it could output code or write files â€“ but the experience wasnâ€™t seamless. Now that Microsoftâ€™s own solution is available, VSÂ Code provides a more polished UI for agentic development. Itâ€™s worth noting that, unlike Zed, VSÂ Codeâ€™s built-in agent (Copilot) is tied to specific cloud models (OpenAI/Anthropic via GitHub) and requires at least a Copilot subscription or GitHub Enterprise license for full use. But thanks to VSÂ Codeâ€™s openness, you do have the choice to use third-party AI agents or frameworks as extensions if you prefer a different model or approach.</p>
</li>
</ul>
<h2 id="developer-experience-and-performance">Developer Experience and Performance</h2>
<ul>
<li>
<p><strong>Performance and Speed:</strong> Zed is engineered for speed. Written in native code (Rust) with custom GPU rendering, it delivers a very snappy editing experience. Users frequently comment on its responsiveness â€“ even compared to lightweight editors. In one benchmark, Zed could process an edit in ~58Â ms, versus ~97Â ms in VSÂ Code (and 75Â ms in Sublime Text). This performance advantage is noticeable when working with AI assistance: agent actions (like applying large diffs or navigating many files) feel smooth, without the lag that sometimes occurs in Electron-based editors. Zedâ€™s UI updates in real-time as the agent works (120Â FPS updates), and the editor remains responsive to user input even during background AI operations. By contrast, VSÂ Code, running on Electron, has more overhead â€“ large projects or extensive AI output can make it feel less snappy. Some developers describe Zed as â€œextremely fast and snappy, without the bloat of VSÂ Code forksâ€. That said, on modern high-end machines VSÂ Code still performs well, but Zedâ€™s lightweight design gives it the edge in raw speed and low latency feedback.</p>
</li>
<li>
<p><strong>Resource Usage:</strong> With its native-code foundation, Zed tends to be efficient in memory and CPU usage for a given project size. VSÂ Code, being essentially a Chromium browser instance, consumes more memory (especially once you add the Copilot extension or others). When an AI agent is running, VSÂ Code might spawn processes for the language server, the Copilot backend, etc., which can tax system resources. Zedâ€™s unified approach (editor and AI in one process) can be leaner. One practical example: editing very large files or performing project-wide refactors has been reported to feel smoother in Zed, whereas VSÂ Code may stutter on huge files (as one user noted, Cursor â€“ a VSCode fork â€“ was sluggish on large files, but Zed handled them fine). Overall, if performance is a priority â€“ for instance, if you want the AI agent to rapidly iterate over many files â€“ Zedâ€™s architecture is advantageous.</p>
</li>
<li>
<p><strong>Developer Interface &amp; Workflow:</strong> Both editors strive to make AI assistance intuitive, but they have different UI paradigms:</p>
<ul>
<li><em>Zedâ€™s UI:</em> The AI conversation in Zed appears in a panel that is essentially a text editor buffer. Uniquely, Zed lets you <strong>edit the conversation text</strong> (including the AIâ€™s responses) before re-sending, which advanced users leverage to fix small errors or remove irrelevant context. This editable chat history is a power-user feature that isnâ€™t common in other tools. Zedâ€™s agent panel also integrates with its multi-buffer interface â€“ you can split the view to show code alongside the agentâ€™s thread or diff review. Because Zed is â€œmultiplayerâ€, the collaboration features (like seeing the agentâ€™s cursor, or even inviting a teammate into the session) enhance the development workflow for pair-programming with AI. Moreover, Zedâ€™s design philosophy is minimalistic: it lacks the myriad of sidebars and tabs that VSÂ Code has, which some find refreshing. A comment on Reddit noted <em>â€œZed shines in its simplicity. The fact it doesn&rsquo;t have tons of addons and extensions actually makes it better (less distraction, easier to focus)â€</em>. On the flip side, this minimalism means some features developers expect are still being filled in (for example, a GUI for certain Git operations or an integrated debugger are relatively new or in beta on Zed).</li>
<li><em>VSÂ Codeâ€™s UI:</em> Developers familiar with VSÂ Code will find Copilotâ€™s integration relatively seamless â€“ it appears as a sidebar chat or inline suggestions. The agent mode adds some new UI elements (a mode toggle, a tools permission dialog, etc.), but generally it follows VSÂ Codeâ€™s standard patterns. Reviewing AI changes in VSÂ Code uses the existing diff view and Source Control panel, which many devs are already comfortable with. One advantage of VSÂ Codeâ€™s maturity is that all the surrounding tooling (integrated terminal, version control UI, test runners, debuggers) are readily available as you use the AI. For instance, after the agent makes changes, you might run your debugger or view a Git diff within the same window. Zed is catching up on such integrated tooling (it has a terminal and basic debugger, but fewer extensions for custom workflows). In terms of <strong>learning curve</strong>, VSÂ Codeâ€™s AI features may actually feel more complex at first (due to many settings, commands, and extension options to configure), whereas Zed offers a more guided experience (one integrated panel). Developers report that â€œeverything just worksâ€ feeling in Zedâ€™s design for AI and collaboration, as it avoids some of the configuration complexity.</li>
</ul>
</li>
<li>
<p><strong>Reliability and Polish:</strong> As of mid-2025, Zedâ€™s agentic editing is a new entrant, and while powerful, some rough edges have been noted. Early adopters have occasionally found the AI behavior in Zed less predictable or lacking feedback compared to more mature systems. For example, one user noted frustration with Zedâ€™s AI â€œnot feeling seamlessâ€ and ended up switching back to Cursor (an AI-focused VSCode fork) for a while. Another pointed out that in Zed it wasnâ€™t as easy to cherry-pick which suggested changes to accept or reject within a single file â€“ you could edit the diff manually, but there was no quick checkbox per hunk like some other tools. The Zed team is actively improving these aspects, but itâ€™s the nature of a young product that some workflows arenâ€™t as refined yet. VSÂ Codeâ€™s Copilot, by contrast, has seen iterations for over a year and benefits from GitHub/Microsoftâ€™s UI expertise â€“ the flow of asking, getting a plan, confirming tools, and applying edits has become reasonably smooth. Copilotâ€™s suggestions (especially with GPT-4) are generally top-notch in quality for code tasks, whereas Zedâ€™s default model (when using their free hosted Claude or the open-source â€œZetaâ€ model for completions) might sometimes lag in quality until you plug in a high-end model via API.</p>
</li>
<li>
<p><strong>Privacy and Offline Use:</strong> Zed puts a big emphasis on privacy and user control of AI. By default, your code and prompts are <strong>not sent to any server owned by Zed</strong> â€“ if you use your own API key or local model, the data stays with those services or your machine. Zed does not log your conversations unless you opt-in to share them for improving the product. Itâ€™s also one of the few editors that supports completely offline AI usage (with local LLMs). You can configure a local  model (via Ollama or LM Studio) and the agent will use that with no internet required. For developers with sensitive code or air-gapped environments, this is a major plus for Zed. VSÂ Codeâ€™s Copilot, on the other hand, always sends code and prompts to the cloud (OpenAI or Anthropic) when using the official plugin. Microsoft has policies to not retain or train on your code for Copilot (especially for enterprise users), but itâ€™s still an external service operating on your code. There is no official offline mode for Copilot. If privacy is paramount, one would have to use a third-party VSÂ Code extension that runs a local model (there are community extensions that hook up to local AI backends, but these may not support the full agent workflow). In summary, Zed gives more flexibility to stay local or control where the AI lives, whereas VSÂ Codeâ€™s best AI features assume a cloud service.</p>
</li>
</ul>
<h2 id="customization-and-extensibility-for-agentic-workflows">Customization and Extensibility for Agentic Workflows</h2>
<ul>
<li>
<p><strong>Zedâ€™s Customization:</strong> Being open-source and designed with AI in mind, Zed is highly customizable. You can fine-tune how the AI behaves via configuration files â€“ for example, you can adjust the agentâ€™s â€œtemperatureâ€ setting or define custom system prompts (â€œrulesâ€) to guide the model. Advanced users can even add <em>custom model profiles</em> in Zedâ€™s settings to use experimental models or specific parameter presets. For extending functionality, Zedâ€™s <strong>extension API</strong> and <strong>Context Server</strong> mechanism allow injection of new capabilities. If you have an external tool or script (say a special linter or a domain-specific code generator), you could expose it to Zedâ€™s agent via the MCP interface, effectively teaching the AI a new â€œskill.â€ Zedâ€™s extension store already includes some MCP servers (for example, one might connect to a web browser automation, or to AWS for cloud operations). Additionally, developers can create <strong>Slash Command extensions</strong> or other plugins in Zed to automate tasks or integrate with external APIs. While Zedâ€™s ecosystem is smaller than VSÂ Codeâ€™s, it is growing, and its focus on AI means many extensions revolve around enhancing AI workflows. The fact that Zedâ€™s entire AI system is open source also means the community can build upon it; for instance, one could fork or modify the agentâ€™s planning logic or contribute improvements.</p>
</li>
<li>
<p><strong>VSÂ Codeâ€™s Extensibility:</strong> VSÂ Code is famous for its extensibility, and that extends to AI tooling as well. Aside from Copilot, there are numerous <strong>AI SDKs and libraries</strong> that integrate with VSÂ Code. For example, <strong>LangChain</strong> (a popular framework for building AI agents) doesnâ€™t have a native VSÂ Code plugin, but one could use VSÂ Codeâ€™s Python or Node.js environment to run LangChain agents that interact with the file system. Some developers have created scripts to use LangChain or <strong>LangGraph</strong> (a framework for structured agent workflows) in concert with VSÂ Code â€“ typically running the agent in the terminal and letting it modify code, then coming back to the editor for review. Itâ€™s not as plug-and-play as Zedâ€™s built-in agent, but itâ€™s possible. More directly, VSÂ Codeâ€™s extension API (in TypeScript/Node) allows anyone to write an extension that uses an LLM. The <strong>CodeGPT</strong> extension we mentioned, for instance, has its own notion of â€œAI Agentsâ€ and even a marketplace of shared agent prompts. This means a VSÂ Code user can experiment with different AI assistants â€“ say one extension specialized in code review bots, another for unit test generation, etc. â€“ and mix and match them. The downside is that these extensions might not all share state or work together (you typically use them separately). However, with the advent of Copilotâ€™s agent mode supporting <strong>tools from other extensions</strong>, weâ€™re likely to see deeper integration: for example, a testing framework extension could register a â€œRun testsâ€ tool that Copilotâ€™s agent will use instead of its generic method, or a database extension could offer a â€œRun DB migrationâ€ tool for the agent. Microsoftâ€™s embrace of the open MCP standard suggests a future where third-party â€œagent toolâ€ plugins can be installed just like any VSÂ Code extension, giving the AI new powers seamlessly in your workflow.</p>
</li>
<li>
<p><strong>Ecosystem and Community:</strong> VSÂ Codeâ€™s huge community means if you need something specific for your agentic workflow, someone may have built it. Want an AI that follows your custom coding style guide? There might be an extension or you can script Copilot via the API (GitHub has started opening up Copilot for CLI and editor integration in other IDEs as well). There are also enterprise solutions built on VSÂ Code â€“ e.g. Amazon CodeWhisperer or Salesforceâ€™s CodeGen (Einstein) integration â€“ which come as VSÂ Code plugins for specialized AI assistance. Zedâ€™s community is more niche at the moment, but very enthusiastic. Many users contribute feedback on Zedâ€™s GitHub and the team iterates quickly (Zed had rapid releases adding missing features throughout 2024â€“2025). If you have a very unique use case, you might end up building a custom VSÂ Code extension (leveraging its APIs to read/write files and show results), whereas on Zed you might write a script using MCP or even modify the editorâ€™s source. Zedâ€™s <strong>â€œbatteries-includedâ€</strong> approach covers most common agentic use cases already, but VSÂ Codeâ€™s <strong>â€œchoose your own pluginsâ€</strong> approach offers flexibility beyond that â€“ albeit at the cost of integrating those pieces yourself.</p>
</li>
</ul>
<h2 id="strengths-and-weaknesses-summary">Strengths and Weaknesses Summary</h2>
<p><strong>Zed â€“ Strengths:</strong> ğŸŸ¢</p>
<ul>
<li><strong>Performance:</strong> Extremely fast and lightweight, providing near-instant feedback even when the AI agent is refactoring large codebases. It feels â€œlean and snappyâ€ compared to Electron-based editors.</li>
<li><strong>Integrated AI Agent:</strong> Agentic editing is a native capability. No setup fuss â€“ you get a powerful Auto-GPT-like coding partner out-of-the-box, with a thoughtful UI (chat in editor, real-time agent cursor) and seamless diff review for changes.</li>
<li><strong>Multi-Model Flexibility:</strong> Use your model of choice â€“ OpenAI, Anthropic, Google, local open-source models, etc.. You can avoid proprietary lock-in or even work offline with local models. This also means cost control (use your own API keys or Zedâ€™s usage-based model plans).</li>
<li><strong>Privacy &amp; Open-Source:</strong> Your code stays private (no telemetry of code by default). Zed is fully open-source (GPL) including its AI features, giving transparency. You can self-host models or even fork the editor.</li>
<li><strong>Collaboration Features:</strong> Real-time collaborative editing is built in. You and teammates (and the AI agent) can all edit together, which is great for pair programming or code review scenarios. Zedâ€™s multiplayer editing and voice chat are unique among code editors at this performance level.</li>
<li><strong>Innovative UI:</strong> Features like editable chat transcripts (letting you correct the AIâ€™s message and resend) and a unified diff that you can live-edit to tweak AI changes, make the AI workflow efficient for power users.</li>
<li><strong>Extensible via MCP:</strong> If the agent needs extra powers, Zed supports community-built extensions (e.g. connect the agent to a web browser or custom CLI) through an open protocol. Itâ€™s ready for creative integration into autonomous workflows.</li>
</ul>
<p><strong>Zed â€“ Weaknesses:</strong> ğŸ”´</p>
<ul>
<li><strong>Ecosystem Maturity:</strong> Zedâ€™s ecosystem is young. It doesnâ€™t (yet) have the thousands of extensions that VSÂ Code does. Common tools (for example, certain linters, test explorers, or AWS deploy plugins) might not be available for Zed yet. If your workflow relies on a specific VSÂ Code extension, Zed likely wonâ€™t have an equivalent immediately.</li>
<li><strong>Feature Gaps:</strong> As a newer editor, some features are still catching up â€“ e.g. GUI git integration is basic compared to VSÂ Codeâ€™s source control pane, and the built-in debugger is in beta. While Zed covers  syntax highlighting/LSP for many languages, niche language support might be less complete than VSÂ Codeâ€™s vast extension library.</li>
<li><strong>AI Polish and Choices:</strong> Zedâ€™s own AI model for inline completions (â€œEdit Predictionâ€) and other assistant features may not be as advanced as OpenAIâ€™s latest. In fact, some advanced autocomplete capability in Zed has been moved behind a paid plan, which drew criticism. By contrast, VSÂ Code users can still use basic IntelliSense and have a free tier of Copilot (limited). Also, a few users report that Zedâ€™s agent can occasionally be inconsistent or harder to control in granular ways (e.g. partial acceptance of changes) compared to more mature tools. Itâ€™s improving rapidly, but itâ€™s not <em>fully</em> battle-tested at the level of VSÂ Codeâ€™s AI in all scenarios.</li>
<li><strong>Learning Curve for New Editor:</strong> Adopting Zed means switching editors, which comes with friction if youâ€™re deeply used to VSÂ Code. Keybindings, workflows, or integrated terminals behave a bit differently. For those who heavily customized VSÂ Code, Zed might feel spartan â€“ by design it foregoes some UI elements. This â€œless is moreâ€ approach might be a downside if you prefer a highly customized IDE environment.</li>
</ul>
<p><strong>VSÂ Code â€“ Strengths:</strong> ğŸŸ¢</p>
<ul>
<li><strong>Extensive Ecosystem:</strong> VSÂ Codeâ€™s biggest advantage is its rich extension library and community. Virtually every developer tool or cloud service has a VSÂ Code extension. For AI specifically, you have multiple choices (Copilot, CodeGPT, TabNine, Codeium, etc.) and can augment them with tools like test runners, Docker integration, database GUIs â€“ all in one editor. This means an <strong>integrated workflow</strong>: the AI agent can coexist with all your other tools in VSÂ Code, making it easier to go from an AI suggestion to debugging to source control without switching context.</li>
<li><strong>Copilotâ€™s AI Quality:</strong> GitHub Copilot (especially with GPT-4 in Copilot X) is a state-of-the-art code assistant. Its training on a huge code corpus and integration with the editorâ€™s context often produces very relevant suggestions. The new agent mode benefits from OpenAIâ€™s cutting-edge reasoning abilities. In practice, Copilotâ€™s code generation and refactoring quality are proven by widespread use, whereas newer entrants are still building trust.</li>
<li><strong>Mature Editor Features:</strong> Outside of AI, VSÂ Code is a full-featured IDE-like editor with stable support for debugging, profiling, intuitive Git UI, multiple project management, etc. When the AI agent suggests code that doesnâ€™t work, you can easily step through it with the debugger or write tests and use VSÂ Codeâ€™s testing panel. This maturity in surrounding features can accelerate verifying and refining AI-written code. Zed is improving here, but VSÂ Code has the lead in â€œwhole development lifecycleâ€ tooling.</li>
<li><strong>Customization &amp; Control:</strong> Virtually every aspect of VSÂ Code can be customized with settings or extensions â€“ if you want the AI to behave differently, you might find an extension or setting to tweak it. For instance, you can adjust Copilotâ€™s promiscuity in suggesting via settings, or use alternative AI extensions in tandem. Power users can even write small VSÂ Code Extension Scripts to automate repetitive tasks. This flexibility means you can tailor the AI-assisted workflow heavily to your needs. Zedâ€™s approach is more fixed (simpler, but less configurable in UI), whereas VSÂ Code lets tinkerers craft their â€œperfectâ€ setup.</li>
<li><strong>Community and Support:</strong> With millions of users, VSÂ Code has extensive documentation, forums, and Q&amp;A for any issue. If the AI integration misbehaves, chances are someone has encountered it and thereâ€™s a GitHub issue or discussion about it. Microsoftâ€™s active development on VSÂ Code and Copilot also means frequent updates and quick bugfixes. In contrast, while the Zed team is very responsive, the user base is smaller â€“ troubleshooting or finding workarounds might require more direct engagement with the Zed community.</li>
</ul>
<p><strong>VSÂ Code â€“ Weaknesses:</strong> ğŸ”´</p>
<ul>
<li><strong>Performance Overhead:</strong> VSÂ Code, running on Electron, is heavier on system resources. When using the AI agent, you might experience some sluggishness, especially on large projects or with many open files. The UI might freeze briefly if the agent is applying very large diffs or if multiple extensions are contending. Itâ€™s not a constant problem on good hardware, but side-by-side, Zedâ€™s lightweight nature often feels more â€œinstantâ€ and distraction-free.</li>
<li><strong>Dependency on Cloud/Subscription:</strong> The best AI experience in VSÂ Code (Copilot Chat with GPT-4) is a paid service with a monthly subscription or enterprise license. There is a free trial and a limited free plan, but heavy use requires payment. Also, without internet or outside of GitHubâ€™s supported regions, Copilot wonâ€™t function. By contrast, Zed allows offline and bring-your-own model scenarios. So in environments where cloud access is restricted or budgets are tight, VSÂ Codeâ€™s agentic capabilities might be less accessible. (Third-party free extensions exist but may not match Copilotâ€™s capabilities or may rely on your OpenAI API key, which still incurs cost.)</li>
<li><strong>Privacy Concerns:</strong> Using VSÂ Code with Copilot means your code prompts are sent to OpenAI/Microsoft servers. While they have privacy safeguards (and an enterprise option to ensure no training on your data), some companies or individuals remain uncomfortable with code leaving the local environment. Achieving a fully local AI solution in VSÂ Code is possible but not straightforward â€“ youâ€™d need to use alternative extensions and host an LLM yourself. In Zed, itâ€™s built-in and straightforward to keep everything local if desired.</li>
<li><strong>Complexity and Configuration:</strong> VSÂ Codeâ€™s flexibility comes at the cost of complexity. New users might find it non-trivial to configure the AI the way they want â€“ there are myriad settings (for example, enabling agent mode requires toggling a setting and ensuring you have the right VSÂ Code version and Copilot extension version). Juggling multiple AI extensions can also lead to confusion or conflicts. Zed, with a singular integrated approach, can be simpler to use for AI assistance once you switch to it. In VSÂ Code, if you donâ€™t want to use Copilot, you must evaluate third-party tools â€“ quality varies, and some features (like the official agent mode) might not be available outside Copilot. Essentially, thereâ€™s more <em>DIY</em> in VSÂ Codeâ€™s approach to agentic dev if you stray from the default path.</li>
<li><strong>Not Built Ground-up for AI:</strong> Finally, VSÂ Code, while now adapted for AI, wasnâ€™t originally built with an AI collaborator in mind. Some workflows (like the way the editor handles very large inserts, or how it displays iterative AI changes) can feel a bit bolted-on. Zedâ€™s philosophy of <em>â€œAI-nativeâ€</em> design (as their tagline suggests â€œbuilt for collaboration with humans and AIâ€) means some interactions are more fluid (like seeing the agentâ€™s live actions). VSÂ Code is catching up fast, but there are moments (especially in early 2025) where the integration isnâ€™t perfect â€“ e.g. occasional glitches with the agentâ€™s state or needing to reset tool permissions. These are minor and being improved, but reflect that VSÂ Code is retrofitting AI features into an existing platform.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Both Zed and VSÂ Code (with Copilot) have robust support for AI-assisted, agentic development as of mid-2025, but they cater to slightly different priorities:</p>
<ul>
<li>
<p><strong>Zed</strong> offers a sleek, high-performance environment where AI is deeply woven into the editing experience. It shines for developers who want an open, hackable editor with AI capabilities that can be customized (or even self-hosted) to their needs. If you value speed, privacy, and an all-in-one approach to an AI coding partner, Zed is a compelling choice â€“ albeit one that might require adapting to a new editor and tolerating a few early-stage quirks.</p>
</li>
<li>
<p><strong>VSÂ Code</strong>, on the other hand, provides a rich, time-tested development environment now augmented by powerful AI through Copilot. Itâ€™s ideal if you want a more mature ecosystem and donâ€™t mind the cloud integration or subscription for top-tier AI. The agentic workflow in VSÂ Code can dramatically boost productivity on complex tasks, and it benefits from VSÂ Codeâ€™s extensive tooling around it. However, itâ€™s a heavier solution and somewhat dependent on proprietary services.</p>
</li>
</ul>
<p>In practice, a developer aiming to use â€œAuto-GPT-styleâ€ autonomous coding can achieve it in <strong>both</strong> editors: Zed gives it to you out-of-the-box in a lightweight form, while VSÂ Code lets you opt-in via Copilot or extensions to get similar capabilities. The best choice may come down to your personal workflow preferences: a streamlined new experience with Zed, or the feature-rich familiar world of VSÂ Code.</p>
<p>Both are evolving rapidly, so we can expect even better integration of autonomous AI workflows in the near future. In mid-2025, itâ€™s truly an exciting time â€“ whether in Zed or VSÂ Code â€“ to experiment with AI agents that <em>â€œcollaborate at 120fpsâ€</em> alongside us in coding, turning natural-language plans into actual code. The tools are here; itâ€™s a matter of which environment makes you more productive and comfortable as you build the future with AI assistance.</p>
<p><strong>Sources:</strong></p>
<ul>
<li><a href="https://zed.dev/docs">Zed official website and docs</a> â€“ <a href="https://zed.dev/docs/ai">AI Features and Agentic Editing</a>, <a href="https://zed.dev/docs/configuration">Configuration options</a>, <a href="https://zed.dev/blog/fastest-ai-editor">&ldquo;Zed: The Fastest AI Code Editor&rdquo;</a> (Zed Blog, May 2025).</li>
<li><a href="https://code.visualstudio.com/docs">VS Code documentation</a> â€“ <a href="https://code.visualstudio.com/docs/copilot/overview">Copilot Chat Agent Mode</a> (code.visualstudio.com, 2025).</li>
<li><a href="https://reddit.com/r/programming">Reddit discussions</a> and user feedback â€“ <a href="https://reddit.com/r/programming/zed_vs_vscode">comparisons of Zed vs other editors</a>.</li>
<li>Media articles â€“ <a href="https://analyticsindiamag.com">Analytics India Magazine on Zed vs VSCode forks</a>, <a href="https://medium.com/@robertbaer/zed-editor-review">Medium post on Zed</a> (Robert Baer), and <a href="https://vinh.dev/blog/zed-review">community blogs</a> (Vinh.dev).</li>
</ul>

</div>

</div>
</div>
<script src="https://blog.herlein.com/js/ui.js"></script>
<script src="https://blog.herlein.com/js/menus.js"></script>










</body>
</html>

